#version 430 core
layout(local_size_x = 16, local_size_y = 16) in;

// Output image
layout(rgba8, binding = 0) uniform image2D outputImage;

// ==================== UBO: Simulation state ====================
layout(std140, binding = 0) uniform SimulationData {
    mat4 invViewProj;
    vec4 cameraPos;
    vec4 torusParams;       // (majorR, minorR, opacity, time)
    ivec4 counts;           // (numParticles, numFusionEvents, screenW, screenH)
};

// ==================== SSBOs ====================
struct GPUParticle {
    vec4 posRadius;
    vec4 color;
};

struct FusionFlash {
    vec4 posAge;       // xyz = position, w = age (0..1)
    vec4 color;        // rgb = color, a = intensity
};

layout(std430, binding = 1) readonly buffer ParticleBuffer {
    GPUParticle particles[];
};

layout(std430, binding = 2) readonly buffer FlashBuffer {
    FusionFlash flashes[];
};

// ==================== CONSTANTS ====================
const float MAX_DIST = 50.0;
const int MAX_STEPS = 128;
const float EPSILON = 0.001;
const float PI = 3.14159265359;

// ==================== NOISE FUNCTIONS ====================
// Simple 3D hash for procedural noise (no texture needed)
float hash31(vec3 p) {
    p = fract(p * vec3(443.8975, 397.2973, 491.1871));
    p += dot(p, p.yzx + 19.19);
    return fract((p.x + p.y) * p.z);
}

float noise3D(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    f = f * f * (3.0 - 2.0 * f); // smoothstep

    float a = hash31(i);
    float b = hash31(i + vec3(1, 0, 0));
    float c = hash31(i + vec3(0, 1, 0));
    float d = hash31(i + vec3(1, 1, 0));
    float e = hash31(i + vec3(0, 0, 1));
    float f2 = hash31(i + vec3(1, 0, 1));
    float g = hash31(i + vec3(0, 1, 1));
    float h = hash31(i + vec3(1, 1, 1));

    return mix(
        mix(mix(a, b, f.x), mix(c, d, f.x), f.y),
        mix(mix(e, f2, f.x), mix(g, h, f.x), f.y),
        f.z
    );
}

// Fractal Brownian Motion — layered noise
float fbm(vec3 p, int octaves) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    for (int i = 0; i < octaves; i++) {
        value += amplitude * noise3D(p * frequency);
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    return value;
}

// ==================== SDF: Torus ====================
float sdTorus(vec3 p, float R, float r) {
    vec2 q = vec2(length(p.xz) - R, p.y);
    return length(q) - r;
}

vec3 torusNormal(vec3 p, float R, float r) {
    float e = 0.001;
    float d = sdTorus(p, R, r);
    return normalize(vec3(
        sdTorus(p + vec3(e, 0, 0), R, r) - d,
        sdTorus(p + vec3(0, e, 0), R, r) - d,
        sdTorus(p + vec3(0, 0, e), R, r) - d
    ));
}

// Distance from point to torus centerline ring (circle of radius R in XZ at y=0)
float distToCenterline(vec3 p, float R) {
    float rXZ = length(p.xz);
    vec2 diff = vec2(rXZ - R, p.y);
    return length(diff);
}

// ==================== Ray-Sphere Intersection ====================
bool intersectSphere(vec3 ro, vec3 rd, vec3 center, float radius, out float t) {
    vec3 oc = ro - center;
    float a = dot(rd, rd);
    float b = 2.0 * dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0) return false;
    float sqrtDisc = sqrt(disc);
    float t0 = (-b - sqrtDisc) / (2.0 * a);
    float t1 = (-b + sqrtDisc) / (2.0 * a);
    if (t0 > 0.0) { t = t0; return true; }
    if (t1 > 0.0) { t = t1; return true; }
    return false;
}

// Intersect ray with a bounding sphere (for early-out optimization)
bool intersectBoundingSphere(vec3 ro, vec3 rd, float R, float r, out float tNear, out float tFar) {
    // Bounding sphere of torus: centered at origin, radius R + r
    float boundR = R + r + 0.1;
    vec3 oc = ro;
    float a = dot(rd, rd);
    float b = 2.0 * dot(oc, rd);
    float c = dot(oc, oc) - boundR * boundR;
    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0) return false;
    float sqrtDisc = sqrt(disc);
    tNear = (-b - sqrtDisc) / (2.0 * a);
    tFar = (-b + sqrtDisc) / (2.0 * a);
    if (tFar < 0.0) return false;
    if (tNear < 0.0) tNear = 0.0;
    return true;
}

// ==================== LIGHTING ====================
vec3 lightDir = normalize(vec3(1.0, 1.5, 0.8));
vec3 lightColor = vec3(1.0, 0.95, 0.9);
vec3 ambientColor = vec3(0.05, 0.06, 0.1);

vec3 shadeTorus(vec3 p, vec3 normal, vec3 rd) {
    // Reactor shell: metallic gray-blue
    vec3 baseColor = vec3(0.15, 0.18, 0.25);
    float diff = max(dot(normal, lightDir), 0.0);
    
    // Fresnel rim — makes edges glow subtly
    float fresnel = pow(1.0 - abs(dot(normal, -rd)), 4.0);
    vec3 rim = vec3(0.1, 0.2, 0.4) * fresnel * 0.5;
    
    // Specular
    vec3 refl = reflect(rd, normal);
    float spec = pow(max(dot(refl, lightDir), 0.0), 64.0);
    
    vec3 color = baseColor * (ambientColor * 2.0 + lightColor * diff * 0.5) + spec * 0.2 + rim;
    return color;
}

// ==================== PLASMA VOLUME ====================
// Computes plasma emission color and density at a point inside the torus tube
vec4 samplePlasma(vec3 p, float R, float r, float time, int numFlashes) {
    float dCenter = distToCenterline(p, R);
    if (dCenter > r) return vec4(0.0);
    
    // Normalized distance from centerline (0 at center, 1 at edge)
    float t = dCenter / r;
    
    // Plasma density profile: peaked at center, falls off toward edge
    // Realistic tokamak: roughly parabolic profile
    float density = max(0.0, 1.0 - t * t);
    density = pow(density, 1.5); // Sharper core
    
    // Toroidal angle (position around the ring)
    float phi = atan(p.z, p.x);
    // Poloidal angle (position around the tube cross-section)
    float rXZ = length(p.xz);
    float theta = atan(p.y, rXZ - R);
    
    // Turbulent noise — makes plasma look alive and dynamic
    vec3 noiseCoord = p * 3.0 + vec3(time * 0.8, time * 0.3, -time * 0.5);
    float turb = fbm(noiseCoord, 4);
    
    // Filamentary structures (magnetic field-aligned) — helical patterns
    float helical = sin(phi * 5.0 + theta * 3.0 + time * 4.0) * 0.5 + 0.5;
    helical *= sin(phi * 8.0 - theta * 2.0 + time * 2.5) * 0.5 + 0.5;
    
    // ELM-like instabilities (Edge Localized Modes) — bright blobs near edge
    float edgeActivity = smoothstep(0.6, 0.9, t) * (turb * 0.8 + 0.2);
    
    // Modulate density with turbulence
    density *= (0.6 + 0.4 * turb);
    density += helical * 0.15 * (1.0 - t);
    density += edgeActivity * 0.3;
    
    // ---- Plasma color temperature ----
    // Core: extremely hot → white-blue
    // Mid:  hot → blue-purple
    // Edge: cooler → purple-red
    vec3 coreColor = vec3(0.7, 0.8, 1.0);      // White-blue (150M K)
    vec3 midColor  = vec3(0.4, 0.3, 1.0);       // Blue-violet
    vec3 edgeColor = vec3(0.8, 0.2, 0.5);       // Magenta-pink
    vec3 hotSpot   = vec3(1.0, 0.95, 0.85);     // White-hot
    
    vec3 plasmaColor;
    if (t < 0.3) {
        plasmaColor = mix(coreColor, midColor, t / 0.3);
    } else if (t < 0.7) {
        plasmaColor = mix(midColor, edgeColor, (t - 0.3) / 0.4);
    } else {
        plasmaColor = edgeColor;
    }
    
    // Hot spots from turbulence
    float hotness = smoothstep(0.65, 0.85, turb) * (1.0 - t * 0.5);
    plasmaColor = mix(plasmaColor, hotSpot, hotness * 0.6);
    
    // Helical filament glow
    plasmaColor += vec3(0.2, 0.1, 0.4) * helical * (1.0 - t) * 0.3;
    
    // Proximity to fusion flash events — local heating (Thermal Blooms)
    for (int i = 0; i < numFlashes; i++) {
        vec3 fPos = flashes[i].posAge.xyz;
        float age = flashes[i].posAge.w;
        if (age >= 1.0) continue;
        
        float dist = length(p - fPos);
        // Heat spreads out as it fades
        float heatRadius = 0.2 + age * 0.4;
        
        // localized energy burst (metaball-ish falloff)
        float heat = max(0.0, 1.0 - dist / heatRadius);
        heat = pow(heat, 2.0) * (1.0 - age); 
        
        // Add density and super-brightness
        density += heat * 3.0;
        
        // Fusion energy is extremely hot (blue-white-violet), not yellow
        vec3 energyColor = vec3(0.8, 0.9, 1.0) * 4.0; 
        plasmaColor = mix(plasmaColor, energyColor, heat * 0.9);
    }
    
    return vec4(plasmaColor, density);
}

// ==================== BACKGROUND ====================
vec3 background(vec3 rd) {
    float t = 0.5 * (rd.y + 1.0);
    vec3 dark = vec3(0.005, 0.005, 0.015);
    vec3 mid = vec3(0.01, 0.015, 0.03);
    vec3 col = mix(dark, mid, t);
    
    // Stars
    float stars = step(0.998, fract(sin(dot(rd.xz * 100.0, vec2(12.9898, 78.233))) * 43758.5453));
    col += stars * 0.2;
    
    return col;
}

// ==================== MAIN RAY TRACE ====================
void main() {
    ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    int screenW = counts.z;
    int screenH = counts.w;
    
    if (gid.x >= screenW || gid.y >= screenH) return;
    
    // Generate ray
    vec2 uv = (vec2(gid) + 0.5) / vec2(screenW, screenH);
    uv = uv * 2.0 - 1.0;
    uv.y = -uv.y;
    
    vec4 nearPoint = invViewProj * vec4(uv, -1.0, 1.0);
    vec4 farPoint  = invViewProj * vec4(uv,  1.0, 1.0);
    nearPoint /= nearPoint.w;
    farPoint  /= farPoint.w;
    
    vec3 ro = cameraPos.xyz;
    vec3 rd = normalize(farPoint.xyz - nearPoint.xyz);
    
    float majorR = torusParams.x;
    float minorR = torusParams.y;
    float torusOpacity = torusParams.z;
    float time = torusParams.w;
    
    int numFlashes = counts.y;
    
    // ======== Early-out: bounding sphere test ========
    float tBoundNear, tBoundFar;
    bool hitsBound = intersectBoundingSphere(ro, rd, majorR, minorR, tBoundNear, tBoundFar);
    
    if (!hitsBound) {
        // Ray misses entirely — just background
        vec3 bg = background(rd);
        bg = bg / (bg + vec3(1.0));
        bg = pow(bg, vec3(1.0 / 2.2));
        imageStore(outputImage, gid, vec4(bg, 1.0));
        return;
    }
    
    // ======== PASS 1: Ray-march — torus shell + volumetric plasma ========
    vec3 torusShellColor = vec3(0.0);
    float torusShellAlpha = 0.0;
    vec3 plasmaAccum = vec3(0.0);
    float plasmaAlphaAccum = 0.0;
    
    float entryT = -1.0;
    float exitT = -1.0;
    
    {
        float t = tBoundNear;
        bool insideTorus = false;
        bool hitShell = false;
        
        // March to find torus entry
        for (int i = 0; i < MAX_STEPS; i++) {
            vec3 p = ro + rd * t;
            float d = sdTorus(p, majorR, minorR);
            
            if (d < EPSILON && !hitShell) {
                // Hit the outer shell
                vec3 normal = torusNormal(p, majorR, minorR);
                torusShellColor = shadeTorus(p, normal, rd);
                torusShellAlpha = torusOpacity;
                hitShell = true;
                entryT = t;
                
                // Step inside: push slightly past surface to avoid self-intersection
                t += EPSILON * 3.0;
                continue;
            }
            
            if (hitShell && d < 0.0) {
                // We're inside the torus tube — this is where plasma is
                insideTorus = true;
                break;
            }
            
            if (t > tBoundFar) break;
            if (hitShell) {
                t += max(abs(d), 0.005);
            } else {
                t += d * 0.8;
            }
        }
        
        // ======== PASS 2: Volumetric plasma ray march inside the torus ========
        if (insideTorus || hitShell) {
            float tStart = max(entryT + EPSILON * 3.0, tBoundNear);
            
            // Optimization: If we entered the shell, we exit at roughly t + 2*d_to_centerline
            // simplified marching logic
            
            float stepSize = minorR * 0.05; // Finer steps for quality
            int plasmaSteps = 80;
            float transmittance = 1.0;
            
            for (int j = 0; j < plasmaSteps; j++) {
                float tSample = tStart + float(j) * stepSize;
                if (tSample > tBoundFar) break;
                
                vec3 pSample = ro + rd * tSample;
                float dSample = sdTorus(pSample, majorR, minorR);
                
                // Only sample inside the torus
                if (dSample > 0.0) {
                    if (entryT > 0.0 && tSample > entryT + minorR * 2.2) break; // Past exit (approx)
                    continue;
                }
                
                // Sample plasma at this point
                vec4 plasma = samplePlasma(pSample, majorR, minorR, time, numFlashes);
                vec3 emitColor = plasma.rgb;
                float density = plasma.a;
                
                // Absorption: Beer-Lambert law
                float absorption = density * stepSize * 6.0;
                float alpha = 1.0 - exp(-absorption);
                
                // Emission-absorption model
                plasmaAccum += emitColor * alpha * transmittance;
                transmittance *= (1.0 - alpha);
                
                if (transmittance < 0.01) break; // Fully opaque
            }
            
            plasmaAlphaAccum = 1.0 - transmittance;
        }
    }
    
    // ======== COMPOSITE ========
    vec3 bg = background(rd);
    
    // 1. Render the core (Plasma + Background)
    // Physical volume rendering: Background seen through plasma
    // Approximate as: mix(bg, plasmaColor, plasmaAlpha)
    vec3 coreColor = mix(bg, plasmaAccum, plasmaAlphaAccum);
    
    // Add extra emissive glow to the core (plasma is self-luminous)
    coreColor += plasmaAccum * 0.5 * plasmaAlphaAccum;
    
    // 2. Render the shell (Container) on top of the core
    // The shell contains the plasma, so we see the core THROUGH the shell
    vec3 finalColor = mix(coreColor, torusShellColor, torusShellAlpha);
    
    // HDR tone mapping
    finalColor = finalColor * (2.51 * finalColor + 0.03) / (finalColor * (2.43 * finalColor + 0.59) + 0.14);
    
    // Gamma correction
    finalColor = pow(clamp(finalColor, 0.0, 1.0), vec3(1.0 / 2.2));
    
    imageStore(outputImage, gid, vec4(finalColor, 1.0));
}
